from io import BytesIO
import numpy as np
import soundfile as sf
from kokoro import KPipeline # Assuming kokoro is installed
from flask import Flask, request, jsonify
from threading import Thread, Lock
import os # Added

# Note: This Flask app part might be better integrated into the main server
# or kept separate if Kokoro needs its own process.
app_kokoro = Flask("kokoro_app")

# Initialize the Kokoro pipeline with American English ('a').
# Adjust lang_code and voice as needed.
kokoro_pipeline = None
kokoro_lock = Lock()

def initialize_kokoro():
    global kokoro_pipeline
    if kokoro_pipeline is None:
        try:
            # Check if KOKORO_ENABLED is true in env
            if os.getenv("KOKORO_ENABLED", "False").lower() == "true":
                print("Initializing Kokoro TTS pipeline...")
                kokoro_pipeline = KPipeline(lang_code='a')
                print("Kokoro TTS pipeline initialized.")
            else:
                 print("Kokoro TTS is disabled via environment variable.")
        except Exception as e:
             print(f"Failed to initialize Kokoro pipeline: {e}")

# Initialize on module load (or lazily on first request)
# initialize_kokoro()

def trim_and_fade(audio, sample_rate, threshold=0.01, fade_duration=0.05):
    """
    Trims leading and trailing silence from an audio signal and applies a fade-in and fade-out.
    Parameters:
        audio (np.array): The audio signal array.
        sample_rate (int): Sampling rate of the audio.
        threshold (float): Amplitude threshold to detect non-silent audio.
        fade_duration (float): Duration in seconds for fade-in and fade-out.
    Returns:
        np.array: The trimmed and smoothed audio signal.
    """
    above_threshold = np.where(np.abs(audio) > threshold)[0]
    if above_threshold.size == 0:
        return audio

    start_idx = above_threshold[0]
    end_idx = above_threshold[-1] + 1
    trimmed_audio = audio[start_idx:end_idx]

    fade_samples = int(fade_duration * sample_rate)
    fade_samples = min(fade_samples, len(trimmed_audio) // 2)

    if fade_samples > 0: # Avoid issues with very short audio
        fade_in = np.linspace(0, 1, fade_samples)
        fade_out = np.linspace(1, 0, fade_samples)
        trimmed_audio[:fade_samples] *= fade_in
        trimmed_audio[-fade_samples:] *= fade_out

    return trimmed_audio

def generate_speech_segment_kokoro(text):
    """
    Generate speech using the Kokoro TTS engine, trim silence, and apply fades.
    Ensures the pipeline is initialized.
    """
    global kokoro_pipeline
    with kokoro_lock:
        if kokoro_pipeline is None:
            initialize_kokoro()
            if kokoro_pipeline is None: # If still None after init attempt
                raise RuntimeError("Kokoro TTS is not initialized or failed to initialize.")

        try:
            if not text.strip():
                print("Input text is empty or whitespace.")
                return None

            generator = kokoro_pipeline(
                text,
                voice='af_bella',  # TODO: Make configurable?
                speed=0.8,
                split_pattern=r'\n+'
            )
            audio_segments = []
            for i, (gs, ps, audio) in enumerate(generator):
                audio_segments.append(audio)

            if not audio_segments:
                print("No audio segments generated by Kokoro pipeline.")
                return None

            full_audio = np.concatenate(audio_segments)
            full_audio = trim_and_fade(full_audio, sample_rate=24000, threshold=0.01, fade_duration=0.05)

            buffer = BytesIO()
            sf.write(buffer, full_audio, 24000, format='WAV')
            buffer.seek(0)
            print("Kokoro speech generation successful.")
            return buffer.getvalue()

        except Exception as e:
            print(f"Error generating speech with Kokoro for text '{text}': {e}")
            # Don't re-raise here, return None or handle appropriately
            return None

# Note: Running this as a separate Flask app might be desired for isolation.
# If integrating into the main app, these routes would need modification.
@app_kokoro.route('/generate_speech', methods=['POST'])
def generate_speech_kokoro_endpoint():
    """ Endpoint for generating speech using the Kokoro TTS engine. """
    text = request.json.get('text', '')
    try:
        result = generate_speech_segment_kokoro(text)
        if result is None:
            print("Kokoro failed to generate audio.")
            return jsonify({"error": "Failed to generate audio with Kokoro"}), 500
        else:
            return result, 200, {'Content-Type': 'audio/wav'}
    except RuntimeError as e:
         return jsonify({"error": str(e)}), 503 # Service unavailable if not initialized
    except Exception as e:
         print(f"Unexpected error in Kokoro endpoint: {e}")
         return jsonify({"error": "Internal server error during Kokoro generation"}), 500

# Main execution block only runs if this script is executed directly.
# Consider removing if this is only meant to be a library.
if __name__ == '__main__':
    def run_kokoro_app():
        initialize_kokoro() # Ensure initialized before starting server
        if kokoro_pipeline: # Only run if initialized
            print("Starting Kokoro App on port 8000...")
            app_kokoro.run(host='0.0.0.0', port=8000, debug=False)
        else:
            print("Kokoro not initialized or enabled, Flask server not started.")

    t_kokoro = Thread(target=run_kokoro_app)
    t_kokoro.start()
    t_kokoro.join() 